"""Domain classes and functions related to the concept of performer
"""


from woodstock.util import utility
from woodstock.music.enums import Vocals, Instrumet
import json


class Performer:
    """The class describing the concept of performer.
    It is assumed that a performer is sufficiently described by their
    name and whether they are a solo performer or a band.

    Illustrates some of the important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, name, is_band=True):
        self.name = name
        self.is_band = is_band
        # self.__n = 'lll'                                    # 'private' field

    # Properties: 'private' fields; run setters and getters in the debugger.
    # Make name a property (after setting up __init__(), __str__(), __eq__(), methods,...).

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name if name and isinstance(name, str) else 'unknown'

    # Add an immutable property (no setter for it)

    @property
    def complete_info(self):                                # immutable property: no setter for it
        return self

    def __str__(self):
        return (self.name + ' (band)' if self.is_band else self.name + ' (solo performer)') \
            if self.name and isinstance(self.name, str) and not self.name == 'unknown' else 'unknown'

    def __eq__(self, other):
        return self.name == other.name if isinstance(other, Performer) else False

    # def play(self, song_title):
    #     print(self.name + ':', f'playing {song_title}...', end=' ')
    #     pass
    #
    # def play_with_greeting(self, song_title, greeting):
    #     self.play(song_title)                               # self.<method>(...) as a mandatory syntax
    #     print(greeting)

    def play(self, song_title, *args, **kwargs):
        """Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, expressions of gratitude and messages. A call example:
            <performer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        print(self.name, f'playing {song_title}...', end=' ')
        print(*args if args else '', ', '.join([v for k, v in kwargs.items()]) if kwargs else '')

    def play_song(self, song_title, *args, **kwargs):
        """Demonstrates calling another method feom the same class (self.<method>(...) as a mandatory syntax).
        """

        self.play(song_title, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, performer_string):
        """Inverted __str__() method.
        Assumes that performer_string is in the format generated by __str__().
        """

        name = False
        is_band = True
        split = performer_string.split(' (')
        if split[0] == 'unknown':
            pass
        elif split[-1] == 'solo performer)':
            name = split[0].rstrip()
            is_band = False
        else:
            name = split[0].rstrip()
        return cls(name, is_band)


class PerformerEncoder(json.JSONEncoder):
    """JSON encoder for Performer objects.
    """

    def default(self, o):
        if isinstance(o, Performer):
            return {"__Performer__": o.__dict__}                # recommendation: always use double quotes with JSON
        return {f"__{o.__class__.__name__}__": o.__dict__}
        # Alternatively, raise TypeError or let JSONEncoder do it:
        # return json.JSONEncoder.default(o)


def performer_json_to_py(performer_json):
    """JSON decoder for Performer objects (object_hook parameter in json.loads()).
    """

    if "__Performer__" in performer_json:
        p = Performer("")
        p.__dict__.update(performer_json["__Performer__"])
        return p
    return performer_json


class Singer(Performer):
    """The class describing the concept of singer.
    It is assumed that a singer is sufficiently described as a Performer,
    with the addition of whether they are a lead or a background singer.
    """

    # Without multiple inheritance
    # def __init__(self, name, vocals, is_band=False):
    #     super().__init__(name, is_band=is_band)
    #     self.vocals = vocals if isinstance(vocals, Vocals) else None

    # With multiple inheritance (works for single-line inheritance as well)
    def __init__(self, vocals, **kwargs):
        super().__init__(**kwargs)                                      # forwards all unused arguments
        self.vocals = vocals if isinstance(vocals, Vocals) else None

    def __str__(self):
        return f'{self.name}, {self.vocals.name.lower().replace("_", " ")}'

    def __eq__(self, other):
        return super().__eq__(other) and (self.vocals == other.vocals) if isinstance(other, Singer) else False

    def play(self, song_title, *args, **kwargs):
        """Overrides the play() method from superclass.
        Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, expressions of gratitude and messages. A call example:
            <singer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        # super().play(song_title, *args, **kwargs)
        print(self.name, f'singing {song_title}...', end=' ')
        print(*args if args else '', ', '.join([v for k, v in kwargs.items()]) if kwargs else '')


class Songwriter(Performer):
    """The class describing the concept of songwriter.
    It is assumed that a songwriter is sufficiently described as a Performer
    who writes songs and plays an instrument.
    """

    # Without multiple inheritance
    # def __init__(self, name, instrument, is_band=False):
    #     super().__init__(name, is_band=is_band)
    #     self.instrument = instrument if isinstance(instrument, Instrumet) else None
    #     self.writes_songs = True

    # With multiple inheritance (works for single-line inheritance as well)
    def __init__(self, instrument, **kwargs):
        super().__init__(**kwargs)                                      # forwards all unused arguments
        self.instrument = instrument if isinstance(instrument, Instrumet) else None
        self.writes_songs = True

    def __str__(self):
        return f'{self.name}, songwriter ({self.instrument.name.lower().replace("_", " ")})'

    def __eq__(self, other):
        return super().__eq__(other) and self.writes_songs if isinstance(other, Songwriter) else False

    def what_do_you_do(self):
        """Just a simple method to describe the concept of songwriter.
        """

        return f"I'm a songwriter and I play {self.instrument}." if self.writes_songs else f"I play {self.instrument}."


class SingerSongwriter(Singer, Songwriter):
    """The class describing the concept of singer-songwriter.
    It is assumed that a singer-songwriter is sufficiently described as a Singer who is simultaneously a Songwriter.
    """

    # def __init__(self, name, vocals, instrument, is_band=False):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)                                      # forwards all unused arguments

    def __str__(self):
        return super().__str__() + f', songwriter ({self.instrument.name.lower().replace("_", " ")})'


if __name__ == "__main__":

    # pass

    # Data

    # Some of the Woodstock performers, Aug 15-16, 1969
    melanie = Performer('Melanie', is_band=False)
    arloGuthrie = Performer('Arlo Guthrie', is_band=False)
    # Some of the Woodstock performers, Aug 16-17, 1969
    gratefulDead = Performer('Grateful Dead', is_band=True)
    jeffersonAirplane = Performer('Jefferson Airplane', is_band=True)
    theWho = Performer('The Who', is_band=True)
    ccr = Performer('Creedence Clearwater Revival', is_band=True)
    # Some of the Woodstock performers, Aug 17-18, 1969
    csny = Performer('Crosby, Stills, Nash and Young', is_band=True)
    jimiHendrix = Performer('Jimi Hendrix', is_band=False)
    theBand = Performer('The Band', is_band=True)

    # Print objects
    print(melanie)
    print(csny)

    # Compare objects
    print(melanie == Performer('Melanie', True))
    print(melanie == Performer('Melanie', False))

    # Access data fields (instance variables)
    print(melanie.is_band)
    melanie.is_band = True
    # melanie.complete_info = 'Melanie, known for "Lay Down"' # no! it's an immutable property (no setter for it)
    # print(melanie.complete_info)                            # (but just getting it is OK)
    print(melanie.name)
    # print(melanie._Performer__n)                            # accessing private field
    # melanie._Performer__n = 'kkk'

    print(melanie)

    # Add new data fields (instance variables)
    #   1. <object>.<new_attr> = <value>
    #   2. <object>.__setattr__('<new_attr>', <value>)      # counterpart: <object>.__getattribute__('<attr>')
    #   3. setattr(<object>, '<new_attr>', <value>))        # counterpart: getattr(<object>, '<attr>')
    # melanie.nationality = 'US'
    # print(melanie.nationality)
    # melanie.__setattr__('nationality', 'US')
    # print(melanie.__getattribute__('nationality'))
    # print(melanie.__getattribute__('name'))
    setattr(melanie, 'nationality', 'US')
    print(getattr(melanie, 'nationality'))

    # Calling methods
    # melanie.play_with_greeting('Lay Down', 'Thank you!')
    # melanie.play('Lay Down', 'Thank you!')
    # melanie.play('Lay Down', 'Thank you!', 'You\'re beautiful!')
    melanie.play('Lay Down', 'Thank you!', 'You\'re beautiful!', love='I love you!')

    # Demonstrate object data fields and methods in Python Console for some built-in classes (boolean, int, object,...)
    # - True + 1
    # - True.__int__()
    # - (1).__class__.__name__
    # - (1).__class__
    # - o.__dir__()
    # - o.__dir__

    # Demonstrate object data fields and methods in Python Console for Performer objects
    print(melanie.__class__)
    print(melanie.__class__.__name__)
    print(melanie.__dict__)
    print(dir())
    print(Performer.__dir__(melanie))

    # Demonstrate @classmethod (from_str())
    melanie_str = melanie.__str__()
    print(Performer.from_str(melanie_str))
    print(melanie.from_str(melanie_str))
    print(melanie.from_str('unknown'))
    print()

    # Demonstrate inheritance
    # object class (like the Object class in Java; all classes inherit from object
    #   try, e.g., list.__mro__ in the console)
    #   object class defines object.__eq__(self, other) etc.
    #   object.__ne__(self, other), the inverse of object.__eq__(self, other),
    #   is provided by Python automatically once object.__eq__(self, other) is implemented
    rogerDaltrey = Singer(name='Roger Daltrey', vocals=Vocals.LEAD_VOCALS)
    print(rogerDaltrey)
    # print(rogerDaltrey == Singer('Roger Daltrey', vocals=Vocals.LEAD_VOCALS))
    print(rogerDaltrey == Singer(name='Roger Daltrey', vocals=Vocals.BACKGROUND_VOCALS))
    print()
    peteTownshend = Songwriter(name='Pete Townshend', instrument=Instrumet.LEAD_GUITAR)
    print(peteTownshend)
    print(peteTownshend == Songwriter(name='Pete Townshend', instrument=Instrumet.LEAD_GUITAR))
    print(peteTownshend == Songwriter(name='Pete Townshend', instrument=Instrumet.RHYTHM_GUITAR))
    peteTownshend.writes_songs = False
    print(peteTownshend == Songwriter(name='Pete Townshend', instrument=Instrumet.RHYTHM_GUITAR))

    # Demonstrate method overriding
    # <singer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
    rogerDaltrey.play('See Me, Feel Me', *['Thank you!', 'You are wonderful!'], yell='Yeah!')
    print()

    # Demonstrate multiple inheritance and MRO.
    # Make sure to read this first: https://stackoverflow.com/a/50465583/1899061 (especially Scenario 3).
    # print(Singer.__mro__)
    # print(SingerSongwriter.__mro__)
    melanie = SingerSongwriter(name='Melanie',
                               is_band=False,
                               vocals=Vocals.LEAD_VOCALS,
                               instrument=Instrumet.RHYTHM_GUITAR)
    print(melanie)
    print()

    # Demonstrate JSON encoding/decoding of Performer objects
    # Single object
    theBand_json = json.dumps(theBand, cls=PerformerEncoder, indent=4)
    print(theBand_json)
    # print(type(theBand_json))
    theBand_python = json.loads(theBand_json, object_hook=performer_json_to_py)
    # print(theBand_python)
    print(theBand_python == theBand)
    print()

    # List of objects
    day3_performers = [csny, jimiHendrix, theBand]
    d3p_json = json.dumps(day3_performers, cls=PerformerEncoder)
    print(d3p_json)
    print(type(d3p_json))
    d3p_python = json.loads(d3p_json, object_hook=performer_json_to_py)
    for p in d3p_python:
        print(p)
    print()

